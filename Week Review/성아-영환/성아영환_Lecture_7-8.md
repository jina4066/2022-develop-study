- **배열(Array)**
    
    여러 데이터를 하나로 묶은 것
    
    일반 변수는 하나의 단일 공간 
    
    배열은 일련의 공간을 여러칸으로 나눈 것
    
    ```java
    int[] array /* 정수형 배열을 가리키는 변수 */ = { 1, 2, 3, 4, 5 } /* 정수형 배열 */ ;
    ```
    
    배열을 사용하면,
    
    수많은 데이터를 단 하나의 변수로 관리할 수 있고
    
    반복문과 함께 코드의 효율을 높일 수 있다.
    
    - 특징
        1. 모두 같은 타입으로 값을 구성
        2. 인덱스(index)로 값을 구분
        3. 길이는 불변
            
            : length keyword를 통해 길이 출력
            
    - 생성
        - 초기화를 통한 생성 : 중괄호 안에 초깃값을 명시하여 만드는 방법
            
            ```java
            int[] array /* 정수형 배열을 가리키는 변수 */ = { 1, 2, 3, 4, 5 } /* 쉼표로 구분된 배열의 초깃값들 */ ;
            ```
            
        - 길이 지정을 통한 생성 : new keyword와 배열의 type, 길이 명시
            
            ```java
            double[] array /* 실수형 배열을 가리키는 변수 */ = new double[4] /* 길이가 4인 실수형 배열을 생성 */ ;
            ```
            
            > 정수형(int) 배열(0), 실수형(double) 배열(0.0), 논리형(boolean) 배열(false), 문자열(char) 배열(null)
            > 
    - 읽고 쓰기
    
    > 레퍼런스변수명[인덱스] (= 대입할값)
    > 
    
    배열 사용 시 인덱스의 범위 주의
    
    :  Java에서 index는 음수일 수 없으며, 배열의 길이보다 작아야한다.
    
    - PLUS
        - 배열은 메소드의 입력변수로 전달될 수도 있다.
        - 문자열은 toCharArray() 메소드를 통해 문자의 배열로 변환 가능 : 문자란 한 글자를 의미하는 타입으로, char로 표기한다.
        - 이차원 배열
            
            : 기본 배열(일차원 배열)을 묶어 새로운 배열을 이루는 형태
            
            ```java
            char[]int[] array = new char[3] /* 행 */ , int[5] /* 열 */ ;
            ```
            
        - 삼차원 배열
            
            : 이차원 배열을 묶어 만든 배열
            
            ```java
            int[][][] cube = {
            	{
            		{1, 2, 3, 4},
            		(5, 6, 7, 8}
            	},
            	{
            		{9, 10, 11, 12},
            		{13, 14, 15, 16}
            	}
            };
            ```
            
        - 정적 배열과 동적 배열
            - 정적 배열
                
                자원을 낭비하거나 프로그램을 다시 컴파일
                
            - 동적 배열
                
                처리할 데이터의 개수가 미정인 경우
                
            - **ArrayList**
                
                : Java에서는 크기가 유동적인 배열을 지원하기 위하여 ArrayList 클래스 제공
                
                - 객체 생성
                    
                    ```java
                    ArrayList<참조타입> 참조변수 = new ArrayList<>();
                    ```
                    
                - 원소 접근
                    
                    ```java
                    참조변수.add(데이터) : 데이터를 동적 배열에 원소로 추가
                    참조변수.remove(인덱스번호) : 동적 배열에서 인덱스 번호의 원소를 제거
                    참조변수.get(인덱스번호) : 동적 배열에서 인덱스 번호의 원소를 추출
                    참조변수.size() : 동적 배열에 포함된 원소 개수
                    ```
                    

- **문자열**
    - 문자열 비교
        
        ==와 != 연산자는 두 문자열의 내용을 비교하는 것이 아닌 동일한 객체인지 검사하는 것!
        
        - String 클래스에서 제공하는 문자열 비교 메소드
            
            ![스크린샷 2022-08-11 오전 4.01.15.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d7bcecf-3eff-4c78-9e96-75f637ab1473/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.01.15.png)
            
    - 문자열 조작
        - String 클래스에서 제공하는 메소드
            
            ![스크린샷 2022-08-11 오전 4.02.18.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06109cd8-8227-46c3-8f08-6dd613989446/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-11_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.02.18.png)
            

- **Procedural & Object-oriented Programming**
    - 절차적 프로그래밍 (Procedural Programming, PP)
        
        대표 언어 : C
        
        절차적(Procedural)? 정확히는 함수(Procedure, Function)의 의미에 근접
        
        - 함수 위주의 구조화된 방식
        - 처음 시작되는 main()함수에서 출발하여 그 안의 내용을 순차적으로 실행하는 방식
        - main()함수는 대부분 또 다른 함수를 순차적으로 호출하는 방식으로 작업을 수행
            - 이를 구조적 또는 절차적 프로그래밍이라고 한다.
            - ‘함수’를 중심으로 프로그램을 설계한 후 거기에 필요한 데이터를 정의
        - 데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점
            - 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래밍과 이해하기가 용이
    - 객체지향 프로그래밍 (Object-oriented Programming, OOP)
        
        대표 언어: Java, C#, Python, C++
        
        - SW규모가 커지면서 동작과 분리되어 전 과정에서 서로 복잡하게 얽혀 있는 데이터
            - 이를 효율적으로 관리하기 위한 새로운 프로그래밍 패러다임 필요
            - 즉, 현실 세계를 객체 단위로 개발하며, 객체는 데이터와 함수를 하나로 묶어 표현
        - 프로그램이 비순차적으로 실행
            - 객체들로 이루어진 코드에서 이벤트가 발생하면 그 이벤트를 처리하는 방식으로 실행
        - 최근에 나오는 대부분의 언어들은 객체지향 언어
            - C++은 완전한 OOP라고 할 수는 없지만, 모든 OOP가 C++을 기초로 만들어졌다고 할 수 있다.
    - PP와 OOP는 반대의 개념인가?
        
        PP의 Procedure가 Object로 확장된 개념에 가깝다!
        
        즉, 공유하는 부분들이 어느 정도 존재하며 둘 다 명령형 프로그래밍의 하위 개념
        
        - PP는 데이터를 중심으로 함수를 만들어 사용
        - OOP는 데이터와 기능(함수)들을 묶어 하나의 객체로 만들어 사용
    - Procedural vs. Object-oriented
        
        **절차적 프로그래밍의 장점**
        
        - 객체나 클래스를 만들 필요 없이 의식의 흐름대로 코딩 가능
        - 필요한 기능을 ‘함수’로 만들어 두기 때문에 같은 코드를 복사 없이 호출하여 사용 가능
            
            : 프로그램의 ‘흐름’을 쉽게 추적 가능
            
        
        **절차적 프로그래밍의 단점**
        
        - 각 코드가 유기적이기 때문에 수정하기가 난해
            - 즉, 새로운 데이터나 기능을 추가하기 위해서는 많은 수정이 필요
            - 프로그램 전체에서 코드를 재사용 할 수가 없어 개발 비용 & 시간이 증가
        - 디버깅 난해
            
            즉, 에러 검사가 어렵다.
            
        
        **객체지향 프로그래밍의 장점**
        
        - 모듈화, 캡슐화로 인해 유지보수에 용이
            - 객체별 관리 가능, 문제가 생기더라도 특정 객체의 코드만 고치면 된다.
        - 객체지향적이기 때문에 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만든다.
        - 객체는 그 자체가 하나의 프로그램이기 때문에 다른 프로그램에서 재사용이 가능
            
            : 높은 코드 재사용성과 확장성
            
        
        **객체지향 프로그래밍의 단점**
        
        - 일반적으로 속도가 상대적으로 느려지고 많은 양의 메모리를 사용
        - 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만들기 위해 설계 과정이 길다.

- **Concept of Object**
    - 객체의 개념
        - 소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것
            - 소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의
            - 필드는 객체 내부에 선언된 변수를 의미하고, 메서드는 객체 내부에 정의된 동작
        - 객체와 클래스
            - 클래스 : 객체의 설계도
            - 객체 : 클래스를 토대로 만들어진 프로그램의 실제 구성 요소
            
            클래스를 토대로 객체를 만드는 과정 : 인스턴스화
            
        - 추상화
            - 현실 세계의 객체는 수많은 상태가 있고 다양한 동작을 하지만,
            클래스에 모두 포함하기는 어렵기에 추상화(Abstraction)하는 과정이 필요
            - 추상화는 현실 세계의 객체에서 불필요한 속성을 제거하고
            중요한 정보만 클래스로 표현하는 일종의 모델링 기법
            - 즉, 사람마다 추상화하는 기법이 같지 않으므로
            각 개발자는 클래스를 다르게 정의 가능